"use strict";(self.webpackChunkpaulohernane_me=self.webpackChunkpaulohernane_me||[]).push([[8652],{4546:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>f,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var a=r(4848),i=r(5680);const s={id:"arrays-and-hashing",title:"Arrays and Hashing"},t=void 0,l={id:"leet-code/arrays-and-hashing",title:"Arrays and Hashing",description:"Dynamic Array",source:"@site/my-brain/leet-code/arrays-and-hashing.md",sourceDirName:"leet-code",slug:"/leet-code/arrays-and-hashing",permalink:"/my-brain/leet-code/arrays-and-hashing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"arrays-and-hashing",title:"Arrays and Hashing"},sidebar:"myBrainSidebar",previous:{title:"Leet Code",permalink:"/my-brain/leet-code/"},next:{title:"Linux",permalink:"/my-brain/linux/"}},f={},o=[{value:"Dynamic Array",id:"dynamic-array",level:2},{value:"Two Pointers",id:"two-pointers",level:2},{value:"Hash Usage",id:"hash-usage",level:2},{value:"Hash Implementation",id:"hash-implementation",level:2},{value:"Hash Collision",id:"hash-collision",level:2},{value:"Hash Set",id:"hash-set",level:2},{value:"Prefix Sums",id:"prefix-sums",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.RP)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"dynamic-array",children:"Dynamic Array"}),"\n",(0,a.jsx)(n.p,{children:"Dynamic array is an array that grows in size as more elements are added to it. It is implemented by creating a new array with double the size of the original array and copying the elements from the original array to the new array."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class DynamicArray:\n    def __init__(self):\n        self.capacity = 1\n        self.size = 0\n        self.arr = [0] * self.capacity\n\n    def add(self, element):\n        if self.size == self.capacity:\n            self.capacity *= 2\n            new_arr = [0] * self.capacity\n            for i in range(self.size):\n                new_arr[i] = self.arr[i]\n            self.arr = new_arr\n        self.arr[self.size] = element\n        self.size += 1\n\n    def get(self, index):\n        if index < 0 or index >= self.size:\n            return -1\n        return self.arr[index]\n\n    def remove(self, index):\n        if index < 0 or index >= self.size:\n            return\n        for i in range(index, self.size - 1):\n            self.arr[i] = self.arr[i+1]\n        self.size -= 1\n"})}),"\n",(0,a.jsx)(n.h2,{id:"two-pointers",children:"Two Pointers"}),"\n",(0,a.jsx)(n.p,{children:"Two pointers is a technique where two pointers are used to solve a problem. The two pointers can be used to solve problems where we need to find a pair of elements that satisfy a condition."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def two_pointers(arr, target):\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return [left, right]\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return [-1, -1]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hash-usage",children:"Hash Usage"}),"\n",(0,a.jsx)(n.p,{children:"Hash is a data structure that stores key-value pairs. It is used to store elements in a way that allows for fast retrieval of elements."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'hash_map = {}\nhash_map[1] = "one"\nhash_map[2] = "two"\nhash_map[3] = "three"\n\nprint(hash_map[1]) # one\nprint(hash_map[2]) # two\nprint(hash_map[3]) # three\n'})}),"\n",(0,a.jsx)(n.h2,{id:"hash-implementation",children:"Hash Implementation"}),"\n",(0,a.jsx)(n.p,{children:"Hash can be implemented using an array of linked lists. The key is hashed to an index in the array and the value is stored in the linked list at that index."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Hash:\n    def __init__(self):\n        self.capacity = 10\n        self.arr = [None] * self.capacity\n\n    def hash(self, key):\n        return key % self.capacity\n\n    def put(self, key, value):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            self.arr[index] = []\n        self.arr[index].append((key, value))\n\n    def get(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return None\n        for k, v in self.arr[index]:\n            if k == key:\n                return v\n        return None\n\n    def remove(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return\n        for i, (k, v) in enumerate(self.arr[index]):\n            if k == key:\n                self.arr[index].pop(i)\n                return\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hash-collision",children:"Hash Collision"}),"\n",(0,a.jsx)(n.p,{children:"Hash collision is when two keys hash to the same index in the hash table. It can be resolved by using a linked list to store the key-value pairs at that index."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Hash:\n    def __init__(self):\n        self.capacity = 10\n        self.arr = [None] * self.capacity\n\n    def hash(self, key):\n        return key % self.capacity\n\n    def put(self, key, value):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            self.arr[index] = []\n        for i, (k, v) in enumerate(self.arr[index]):\n            if k == key:\n                self.arr[index][i] = (key, value)\n                return\n        self.arr[index].append((key, value))\n\n    def get(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return None\n        for k, v in self.arr[index]:\n            if k == key:\n                return v\n        return None\n\n    def remove(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return\n        for i, (k, v) in enumerate(self.arr[index]):\n            if k == key:\n                self.arr[index].pop(i)\n                return\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hash-set",children:"Hash Set"}),"\n",(0,a.jsx)(n.p,{children:"Hash set is a set that stores unique elements. It is implemented using a hash table where the key is the element and the value is a dummy value."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class HashSet:\n    def __init__(self):\n        self.capacity = 10\n        self.arr = [None] * self.capacity\n\n    def hash(self, key):\n        return key % self.capacity\n\n    def add(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            self.arr[index] = []\n        for k in self.arr[index]:\n            if k == key:\n                return\n        self.arr[index].append(key)\n\n    def contains(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return False\n        for k in self.arr[index]:\n            if k == key:\n                return True\n        return False\n\n    def remove(self, key):\n        index = self.hash(key)\n        if self.arr[index] is None:\n            return\n        for i, k in enumerate(self.arr[index]):\n            if k == key:\n                self.arr[index].pop(i)\n                return\n"})}),"\n",(0,a.jsx)(n.h2,{id:"prefix-sums",children:"Prefix Sums"}),"\n",(0,a.jsx)(n.p,{children:"Prefix sums is a the technique of storing the sum of all elements in the array."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"\narr = [1, 2, 3, 4, 5]\nprefix_sum = [0] * len(arr)\n\nprefix_sum[0] = arr[0]\nfor i in range(1, len(arr)):\n    prefix_sum[i] = prefix_sum[i-1] + arr[i]\n\nprint(prefix_sum[2]) # 6 = 3 + 3 = prefix_sum[1] + arr[2] = arr[0] + arr[1] + arr[2] = 1 + 2 + 3\nprint(prefix_sum[4]) # 15 = 10 + 5 = prefix_sum[3] + arr[4] = arr[0] + arr[1] + arr[2] + arr[3] + arr[4] = 1 + 2 + 3 + 4 + 5 \n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.RP)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},5680:(e,n,r)=>{r.d(n,{RP:()=>o});var a=r(6540);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function t(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,a,i=function(e,n){if(null==e)return{};var r,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var f=a.createContext({}),o=function(e){var n=a.useContext(f),r=n;return e&&(r="function"==typeof e?e(n):t(t({},n),e)),r},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var r=e.components,i=e.mdxType,s=e.originalType,f=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),c=o(r),p=i,u=c["".concat(f,".").concat(p)]||c[p]||d[p]||s;return r?a.createElement(u,t(t({ref:n},h),{},{components:r})):a.createElement(u,t({ref:n},h))}));h.displayName="MDXCreateElement"}}]);