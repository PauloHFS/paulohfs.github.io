"use strict";(self.webpackChunkpaulohernane_me=self.webpackChunkpaulohernane_me||[]).push([[1087],{2941:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>o,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"concurrent-programming/basic-synchronization-patterns","title":"Basic Synchronization Patterns","description":"This are the basic synchronization patterns that can be used to solve a variety of synchronization problems.","source":"@site/my-brain/concurrent-programming/basic-synchronization-patterns.md","sourceDirName":"concurrent-programming","slug":"/concurrent-programming/basic-synchronization-patterns","permalink":"/my-brain/concurrent-programming/basic-synchronization-patterns","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Concurrent Programming","permalink":"/my-brain/tags/concurrent-programming"},{"inline":true,"label":"Synchronization Patterns","permalink":"/my-brain/tags/synchronization-patterns"},{"inline":true,"label":"Semaphore","permalink":"/my-brain/tags/semaphore"},{"inline":true,"label":"Mutex","permalink":"/my-brain/tags/mutex"},{"inline":true,"label":"Exclusion","permalink":"/my-brain/tags/exclusion"},{"inline":true,"label":"Race Condition","permalink":"/my-brain/tags/race-condition"},{"inline":true,"label":"Rendezvous","permalink":"/my-brain/tags/rendezvous"},{"inline":true,"label":"Barrier","permalink":"/my-brain/tags/barrier"},{"inline":true,"label":"Reusable Barrier","permalink":"/my-brain/tags/reusable-barrier"},{"inline":true,"label":"Multiplex","permalink":"/my-brain/tags/multiplex"},{"inline":true,"label":"Signalizing","permalink":"/my-brain/tags/signalizing"},{"inline":true,"label":"Busy Waiting","permalink":"/my-brain/tags/busy-waiting"},{"inline":true,"label":"Conditional Variables","permalink":"/my-brain/tags/conditional-variables"}],"version":"current","frontMatter":{"id":"basic-synchronization-patterns","title":"Basic Synchronization Patterns","tags":["Concurrent Programming","Synchronization Patterns","Semaphore","Mutex","Exclusion","Race Condition","Rendezvous","Barrier","Reusable Barrier","Multiplex","Signalizing","Busy Waiting","Conditional Variables"]},"sidebar":"myBrainSidebar","previous":{"title":"Concurrent Programming","permalink":"/my-brain/concurrent-programming/"},"next":{"title":"Classical Synchronization Problems","permalink":"/my-brain/concurrent-programming/classical-synchronization-problems"}}');var a=i(4848),l=i(8453);const t={id:"basic-synchronization-patterns",title:"Basic Synchronization Patterns",tags:["Concurrent Programming","Synchronization Patterns","Semaphore","Mutex","Exclusion","Race Condition","Rendezvous","Barrier","Reusable Barrier","Multiplex","Signalizing","Busy Waiting","Conditional Variables"]},s="Basic Synchronization Patterns",d={},c=[{value:"Signalizing",id:"signalizing",level:2},{value:"Rendezvous",id:"rendezvous",level:2},{value:"Mutex",id:"mutex",level:2},{value:"Multiplex",id:"multiplex",level:2},{value:"Barrier",id:"barrier",level:2},{value:"Reusable Barrier",id:"reusable-barrier",level:2},{value:"Queue",id:"queue",level:2},{value:"Exclusive Queue",id:"exclusive-queue",level:3},{value:"Condition Variables",id:"condition-variables",level:2}];function h(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"basic-synchronization-patterns",children:"Basic Synchronization Patterns"})}),"\n",(0,a.jsx)(n.p,{children:"This are the basic synchronization patterns that can be used to solve a variety of synchronization problems."}),"\n",(0,a.jsxs)(n.p,{children:["In the examples the ",(0,a.jsx)(n.code,{children:"main"})," function is the main thread, and the ",(0,a.jsx)(n.code,{children:"f1"})," and ",(0,a.jsx)(n.code,{children:"f2"})," are functions that can be run by threads, they run concurrently and can be run in any order."]}),"\n",(0,a.jsx)(n.h2,{id:"signalizing",children:"Signalizing"}),"\n",(0,a.jsx)(n.p,{children:"Signalizing is a pattern used to a thread wait for another thread to run something. This pattern is used to avoid busy waiting."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"f1"})," must run before ",(0,a.jsx)(n.code,{children:"f2"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Thread A or B can run before the other."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\nf1Done = Semaphore(0)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\nf1()\nf1Done.signal()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nf1Done.wait()\nf2()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this case the semaphore ",(0,a.jsx)(n.code,{children:"f1Done"})," start with the value ",(0,a.jsx)(n.code,{children:"0"}),". So, if Thread B gain CPU first, in the ",(0,a.jsx)(n.code,{children:"wait"})," the semaphore will be decremented and will become ",(0,a.jsx)(n.code,{children:"-1"}),", so the thread will be blocked. When Thread A gain CPU, the semaphore will be incremented and will become ",(0,a.jsx)(n.code,{children:"0"}),", so the Thread B will be unblocked and will run ",(0,a.jsx)(n.code,{children:"f2"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If Thread A gain CPU first, the semaphore will be incremented and will become ",(0,a.jsx)(n.code,{children:"1"}),", so the Thread B will not be blocked."]}),"\n",(0,a.jsxs)(n.p,{children:["Using this pattern, we can guarantee that ",(0,a.jsx)(n.code,{children:"f1"})," will run before ",(0,a.jsx)(n.code,{children:"f2"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"rendezvous",children:"Rendezvous"}),"\n",(0,a.jsx)(n.p,{children:"Rendezvous is synchronization problem that occurs when Thread A has to wait to Thread B and Thread B has to wait to Thread A."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"a1"})," must runs before ",(0,a.jsx)(n.code,{children:"b2"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"b1"})," must runs before ",(0,a.jsx)(n.code,{children:"a2"}),";"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\naArrived = Semaphore(0)\nbArrived = Semaphore(0)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\na1()\naArrived.signal() # signalize that Thread A arrived at rendezvous \nbArrived.wait() # wait to Thread B arrive at rendezvous\na2()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nb1()\nbArrived.signal() # signalize that Thread B arrived at rendezvous\naArrived.wait() # wait to Thread A arrive at rendezvous\nb2()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"mutex",children:"Mutex"}),"\n",(0,a.jsxs)(n.p,{children:["Mutex is a solution to enforce mutual exclusion (event cannot happens at the same time) granting that only one thread will access the lines inside the block starting with ",(0,a.jsx)(n.code,{children:"mutex.wait()"})," and ",(0,a.jsx)(n.code,{children:"mutex.signal()"}),", this block of code is called ",(0,a.jsx)(n.code,{children:"critical region"}),". A common problems works with threads is operation on shared variables, a sum like ",(0,a.jsx)(n.code,{children:"count = count + 1"})," take more that 1 operation on the CPU, so only one thread should run this line per time, otherwise the result will be wrong."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"count"})," is a shared variable."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"count = count + 1"})," is a critical region."]}),"\n",(0,a.jsx)(n.li,{children:"only one thread can run the critical region at the same time."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\nmutex = Semaphore(1)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\nmutex.wait()        # wait to the mutex be free\ncount = count + 1   # only one thread can run this line per time\nmutex.signal()      # signalize that the mutex is free\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nmutex.wait()        # wait to the mutex be free\ncount = count + 1   # only one thread can run this line per time\nmutex.signal()      # signalize that the mutex is free\n"})}),"\n",(0,a.jsx)(n.h2,{id:"multiplex",children:"Multiplex"}),"\n",(0,a.jsxs)(n.p,{children:["Multiplex is a solution like Multex, but now we can have ",(0,a.jsx)(n.code,{children:"n"})," threads running the ",(0,a.jsx)(n.code,{children:"critical region"})," at the same time."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["the ",(0,a.jsx)(n.code,{children:"critical region"})," should be executed only by ",(0,a.jsx)(n.code,{children:"n"})," threads at the same time, in this case lets simulate with ",(0,a.jsx)(n.code,{children:"n = 2"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\nn = 2\nmultiplex = Semaphore(n)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\nmultiplex.wait()\n# critical region\nmultiplex.signal()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nmultiplex.wait()\n# critical region\nmultiplex.signal()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread C\n\nmultiplex.wait()\n# critical region\nmultiplex.signal()\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, only 2 threads can run the ",(0,a.jsx)(n.code,{children:"critical region"})," at the same time. So if Thread A and B run first ",(0,a.jsx)(n.code,{children:"mutex.wait()"}),", then they are running the ",(0,a.jsx)(n.code,{children:"critical region"}),", the Thread C will be blocked in the ",(0,a.jsx)(n.code,{children:"mutex.wait()"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"For this example, we can have 3 scenarios:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Thread A"}),(0,a.jsx)(n.th,{children:"Thread B"}),(0,a.jsx)(n.th,{children:"Thread C"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Running"}),(0,a.jsx)(n.td,{children:"Running"}),(0,a.jsx)(n.td,{children:"Waiting"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Running"}),(0,a.jsx)(n.td,{children:"Waiting"}),(0,a.jsx)(n.td,{children:"Running"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Waiting"}),(0,a.jsx)(n.td,{children:"Running"}),(0,a.jsx)(n.td,{children:"Running"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"barrier",children:"Barrier"}),"\n",(0,a.jsxs)(n.p,{children:["Barrier is a generalization of the Rendezvous pattern. In this pattern, we can have ",(0,a.jsx)(n.code,{children:"n"})," threads waiting for each other. So, when ",(0,a.jsx)(n.code,{children:"n"})," threads arrive at the barrier, all threads are unblocked."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"n-1"})," threads must run ",(0,a.jsx)(n.code,{children:"barrier.wait()"})," before all threads can continue."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\nn = 3\nbarrier = Barrier(n)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\na1()\nbarrier.wait()\na2()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nb1()\nbarrier.wait()\nb2()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread C\n\nc1()\nbarrier.wait()\nc2()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let simulate a execution with this 3 threads:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The Schedule will order the threads in this order: A -> B -> C;"}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Thread A will run ",(0,a.jsx)(n.code,{children:"a1()"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread A will run ",(0,a.jsx)(n.code,{children:"barrier.wait()"}),", the barrier will be decremented to ",(0,a.jsx)(n.code,{children:"2"}),", and the thread will be blocked;"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread B will run ",(0,a.jsx)(n.code,{children:"b1()"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread B will run ",(0,a.jsx)(n.code,{children:"barrier.wait()"}),", the barrier will be decremented to ",(0,a.jsx)(n.code,{children:"1"}),", and the thread will be blocked;"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread C will run ",(0,a.jsx)(n.code,{children:"c1()"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread C will run ",(0,a.jsx)(n.code,{children:"barrier.wait()"}),", the barrier will be decremented to ",(0,a.jsx)(n.code,{children:"0"}),", and all threads will be unblocked;"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Lets implement a Barrier using a Semaphore:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"class Barrier() \n    def __init__(self, n):\n        self.count = n\n        self.mutex = Semaphore(1) # mutex to protect the count\n        self.barrier = Semaphore(0)\n\n    def wait(self):\n        self.mutex.wait() \n        self.count -= 1\n        if self.count != 0:\n            self.barrier.wait() # block n - 1 first threads, the last thread never run this line\n        self.mutex.signal()\n        self.barrier.signal() # the last thread will be the first to run this line, will unblock one thread and the other threads will run this line in sequence\n"})}),"\n",(0,a.jsx)(n.h2,{id:"reusable-barrier",children:"Reusable Barrier"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Need to study more about this pattern."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"queue",children:"Queue"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Need to study more about this pattern."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Queue is a pattern where a thread can wait for another thread to run something. We want that on thread run a code alongside other runs another."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"f1"})," must run alongside ",(0,a.jsx)(n.code,{children:"f2"}),";"]}),"\n",(0,a.jsx)(n.li,{children:"Thread A or B can run before the other."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\nf1Queue = Semaphore(0)\nf2Queue = Semaphore(0)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\nf2Queue.signal() # Thread A signalize that it wants to run f1 alongside f2\nf1Queue.wait() # Thread A wait to Thread B signalize that it can run f1\nf1()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nf1Queue.signal() # Thread B signalize that it wants to run f2 alongside f1\nf2Queue.wait() # Thread B wait to Thread A signalize that it can run f2\nf2()\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"This is like a Rendezvous"})}),"\n",(0,a.jsx)(n.p,{children:"Lets simulate a execution with this 2 threads:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The Schedule will order the threads in this order: A -> B;"}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Thread A will run ",(0,a.jsx)(n.code,{children:"f2Queue.signal()"}),", the semaphore ",(0,a.jsx)(n.code,{children:"f2Queue"})," will be incremented to ",(0,a.jsx)(n.code,{children:"1"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread A will run ",(0,a.jsx)(n.code,{children:"f1Queue.wait()"}),", the semaphore ",(0,a.jsx)(n.code,{children:"f1Queue"})," will be decremented to ",(0,a.jsx)(n.code,{children:"-1"}),", and the thread will be blocked;"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread B will run ",(0,a.jsx)(n.code,{children:"f1Queue.signal()"}),", the semaphore ",(0,a.jsx)(n.code,{children:"f1Queue"})," will be incremented to ",(0,a.jsx)(n.code,{children:"0"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Thread B will run ",(0,a.jsx)(n.code,{children:"f2Queue.wait()"}),", the semaphore ",(0,a.jsx)(n.code,{children:"f2Queue"})," will be decremented to ",(0,a.jsx)(n.code,{children:"0"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Now both threads are unblocked and can run ",(0,a.jsx)(n.code,{children:"f1"})," and ",(0,a.jsx)(n.code,{children:"f2"})," alongside."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"exclusive-queue",children:"Exclusive Queue"}),"\n",(0,a.jsx)(n.p,{children:"Exclusive Queue is a pattern where the thread that is blocking is only running with the thread that signalize it."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# main\n\nf1Counter = f2Counter = 0\nmutex = Semaphore(1)\nf1Queue = Semaphore(0)\nf2Queue = Semaphore(0)\nrendezvous = Semaphore(0)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread A\n\nmutex.wait()\nif f1Count > 0:\n    f1Counter--\n    f1Queue.signal()\nelse:\n    f2Counter++\n    mutex.signal()\n    f2Queue.wait() #t1\n\nf1()\nrendezvous.wait()\nmutex.signal()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"# Thread B\n\nmutex.wait()\nif f2Counter > 0:\n    f2Counter--\n    f2Queue.signal()\nelse:\n    f1Counter++\n    mutex.signal()\n    f1Queue.wait()\n\nf2()\nrendezvous.signal()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"condition-variables",children:"Condition Variables"}),"\n",(0,a.jsx)(n.p,{children:"This pattern is used to allow a thread take of the scheduling queue until there is a signal from another thread. This allow a thread wait until another thread finish some work."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"// main\n\nint is_done;\nmutex_t done_lock;\ncond_t done_cond;\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"// Thread A\n\nmutex_lock(&done_lock) // lock the mutex to access is_done\nis_done = 1; // signalize that the work is done\ncond_signal(&done_cond) // signalize to all threads that are waiting in the done_cond\nmutex_unlock(&done_lock) // unlock the mutex \n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c",children:"// Thread B\n\nmutex_lock(&done_lock) // lock the mutex to access is_done\nif (!is_done) // if the work is not done\n    cond_wait(&done_cond, &done_lock) // wait until the condition is done\nmutex_unlock(&done_lock) // unlock the mutex\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this example, the Thread B will wait until the Thread A signalize that the work is done."}),"\n",(0,a.jsx)(n.p,{children:"The thread B will execute this steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Lock the mutex to access the variable ",(0,a.jsx)(n.code,{children:"is_done"}),";"]}),"\n",(0,a.jsx)(n.li,{children:"Check if the work is done;"}),"\n",(0,a.jsxs)(n.li,{children:["If the work is not done, call ",(0,a.jsx)(n.code,{children:"cond_wait"})," that will put thread to wait until the ",(0,a.jsx)(n.code,{children:"done_cond"})," is done, and will unlock the mutex ",(0,a.jsx)(n.code,{children:"done_lock"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["When the ",(0,a.jsx)(n.code,{children:"done_cond"})," is done, the thread will be unblocked and will lock the mutex ",(0,a.jsx)(n.code,{children:"done_lock"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["Then the thread will unlock the mutex ",(0,a.jsx)(n.code,{children:"done_lock"})," and will continue the execution.;"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["There is another command called ",(0,a.jsx)(n.code,{children:"broadcast(&done_cond)"})," that will signalize to all threads that are waiting in the ",(0,a.jsx)(n.code,{children:"done_cond"}),"."]})]})}function o(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>s});var r=i(6540);const a={},l=r.createContext(a);function t(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);